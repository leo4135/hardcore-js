/**
 * DAY 1 — BLOCK A: Замыкания и Scope
 * 
 * TODO: Предскажи поведение каждого фрагмента.
 * Объясни, почему именно так, а не иначе.
 * Обрати внимание на момент создания замыкания и что именно захватывается.
 */

// ============================================
// ФРАГМЕНТ 1: Классическая ловушка с циклом
// ============================================

const functions = [];

for (var i = 0; i < 3; i++) {
  functions.push(() => console.log(i));
}

functions.forEach(fn => fn());

// TODO: Выведется 3, 3, 3, потому что у var i - функциональная область видимости, а не блочная, поэтому цикл поместит в массив три стрелочных функции, не имеющих своего
// контекста. А, следовательно, они будут смотреть на i, которое всплыло в данном случае в global.
// TODO: Как исправить, чтобы выводилось 0, 1, 2? Нужно объявить i через let


// ============================================
// ФРАГМЕНТ 2: Замыкание с изменяемой переменной
// ============================================

function createCounter() {
  let count = 0;
  
  return {
    increment: () => ++count,
    getValue: () => count,
    // Внимание: возвращаем объект, а не функцию
    reset: () => { count = 0; }
  };
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1.increment();
counter1.increment();
counter2.increment();

console.log(counter1.getValue());
console.log(counter2.getValue());

// TODO: Что выведется? Почему у каждого counter свой count?
// Выведется 1, 2. Свой count, потому что при вызове функция возвращает новый объект, который на момент вызова функции будет ссылаться на count
// TODO: Что произойдёт, если заменить let на var?
// Если заменить на var, по идее, ничего не должно измениться, так как у var функциональная область видимости и он за пределы createCounter не должен всплыть


// ============================================
// ФРАГМЕНТ 3: Замыкание и setTimeout
// ============================================

for (let j = 0; j < 3; j++) {
  setTimeout(() => {
    console.log('Timeout:', j);
  }, 100);
}

// TODO: Что выведется? Почему let решает проблему?
// Выведется 0, 1, 2. let решается проблему, потому что console.log запоминает ссылку на j в момент помещения в макротаски. При каждой итерации j -новая переменная.
// Соответственно, на каждой итерации ссылка на объект будет отличаться. Поэтому будет выводиться соответствующее значение
// TODO: Что было бы, если использовать var?
// вывелось бы 3, 3, 3. Потому что j всплыл бы и на момент вызова консолей из макротасков, равнялся бы трем


// ============================================
// ФРАГМЕНТ 4: Вложенные замыкания и параметры
// ============================================

function outer(x) {
  return function inner(y) {
    return function deepest(z) {
      return x + y + z;
    };
  };
}

const fn1 = outer(10);
const fn2 = fn1(20);
const result = fn2(30);

console.log(result);

// TODO: Что выведется? Какие переменные доступны в deepest?
// Выведется 60, потмоу что функция будет запоминать контекст, при котором она была вызвана. В deepest доступны все - x, y, z
// TODO: Что произойдёт, если вызвать fn2(30) дважды с разными аргументами?
// каждый раз будет пересчитывать сумму исходя из того, что x + y - статичный, а z - будет в зависимости от того, что мы передали в аргументы вычисляться


// ============================================
// ФРАГМЕНТ 5: Замыкание и мутация объекта
// ============================================

function createState() {
  const state = { value: 0 };
  
  return {
    getState: () => state,
    increment: () => state.value++,
    // Попытка "защитить" state
    getValue: () => state.value
  };
}

const state1 = createState();
state1.increment();
state1.increment();

const stateRef = state1.getState();
stateRef.value = 999;

console.log(state1.getValue());

// TODO: Что выведется? Почему?
// Выведется 2. ПОтому что state1 - зафиксирует при вызове лексическое окружение.
// Затем, stateRef - просто примет свойство со значением, без контекста.
// TODO: Как действительно защитить state от внешних изменений?
// Использовать readonly
